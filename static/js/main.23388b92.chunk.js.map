{"version":3,"sources":["theme.js","store/app/index.js","lib/spotify-api.js","store/playlists/index.js","store/albums/selectors.js","store/albums/index.js","store/store.js","store/app/selectors.js","config/spotify.js","components/AuthoriseSpotify.js","store/playlists/selectors.js","components/Playlists.js","components/Albums.js","lib/useUrlHashParams.js","App.js","serviceWorker.js","index.js"],"names":["theme","createMuiTheme","slice","createSlice","name","initialState","apiToken","view","reducers","setApiToken","state","action","payload","setView","clearStaleApiToken","actions","reducer","baseUrl","spotifyFetch","a","spotifyAccessToken","url","fetch","headers","Authorization","response","ok","json","window","localStorage","setItem","store","dispatch","playlistUrl","playlistId","offset","limit","URL","searchParams","append","href","status","playlists","selectedPlaylistId","setStatus","playlistsReceived","push","items","setSelectedPlaylistId","getPlaylistId","albums","getStatus","getPagination","pagination","getAlbums","appSlice","setPlaylistId","songs","songsReceived","showAlbums","groupBy","song","track","album","id","showArtists","configureStore","app","getApiToken","getView","spotifyApp","clientId","redirectUrl","AuthoriseSpotify","spotifyAuthUrl","rel","getPlaylists","getSelectedPlaylistId","Playlists","useSelector","useEffect","length","console","log","fetchPlaylists","button","Button","variant","color","onClick","List","className","map","playlist","ListItem","key","selected","Album","albumSongs","coverImageUrl","images","title","releaseType","total_tracks","src","alt","Albums","current","next","fetchSongs","cells","Object","entries","useUrlHashParams","hashParams","r","q","useLocation","hash","substring","match","exec","decodeURIComponent","AppContent","urlApiToken","access_token","savedApiToken","getItem","AppContainer","ThemeProvider","CssBaseline","Container","Boolean","location","hostname","ReactDOM","render","StrictMode","App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.23388b92.chunk.js","sourcesContent":["import { createMuiTheme } from \"@material-ui/core/styles\";\n\n// A custom theme for this app…\n// …or not, need to better understand how to define a custom theme from 1-3 colours.\nconst theme = createMuiTheme({\n  // palette: {\n  //   primary: {\n  //     main: \"#ff0022\",\n  //   },\n  //   secondary: {\n  //     main: \"#22ff00\",\n  //   },\n  //   error: {\n  //     main: orange.A400,\n  //   },\n  //   background: {\n  //     default: \"#cga\",\n  //   },\n  //   action: {\n  //     selected: \"green\",\n  //   },\n  // },\n});\n\nexport default theme;\n","import { createSlice } from \"@reduxjs/toolkit\";\n\nconst slice = createSlice({\n  name: \"spotifyClient\",\n  initialState: {\n    apiToken: \"\",\n    view: \"playlists\",\n  },\n  reducers: {\n    setApiToken(state, action) {\n      state.apiToken = action.payload.apiToken;\n    },\n    setView(state, action) {\n      state.view = action.payload.view;\n    },\n  },\n});\n\nconst clearStaleApiToken = () => setApiToken({ apiToken: \"\" });\n\nconst { actions, reducer } = slice;\nconst { setApiToken, setView } = actions;\n\nexport { clearStaleApiToken, setApiToken, setView };\nexport default reducer;\n","import store from \"../store/store.js\";\nimport { clearStaleApiToken } from \"../store/app\";\n\nconst baseUrl = \"https://api.spotify.com/v1/\";\n\nasync function spotifyFetch({ spotifyAccessToken, url }) {\n  const response = await fetch(url, {\n    headers: {\n      Authorization: `Bearer ${spotifyAccessToken}`,\n    },\n  });\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  window.localStorage.setItem(\"apiToken\", \"\");\n  store.dispatch(clearStaleApiToken());\n  return [];\n}\n\nfunction playlistUrl({ playlistId, offset = 0, limit = 100 }) {\n  const playlistUrl = new URL(`${baseUrl}playlists/${playlistId}/tracks`);\n  playlistUrl.searchParams.append(\"offset\", offset);\n  playlistUrl.searchParams.append(\"limit\", limit);\n  return playlistUrl.href;\n}\n\nexport { baseUrl, spotifyFetch, playlistUrl };\n","import { createSlice } from \"@reduxjs/toolkit\";\n\nimport { baseUrl, spotifyFetch } from \"../../lib/spotify-api\";\n\nconst slice = createSlice({\n  name: \"playlists\",\n  initialState: {\n    status: \"idle\",\n    playlists: [],\n    selectedPlaylistId: \"\",\n  },\n  reducers: {\n    setStatus(state, action) {\n      state.status = action.payload.status;\n    },\n    playlistsReceived(state, action) {\n      state.playlists.push(...action.payload.items);\n    },\n    setSelectedPlaylistId(state, action) {\n      state.selectedPlaylistId = action.payload.selectedPlaylistId;\n    },\n  },\n});\n\nconst fetchPlaylists = ({ spotifyAccessToken }) => async (dispatch, state) => {\n  dispatch(setStatus(\"loading\"));\n\n  try {\n    let url = baseUrl + \"me/playlists\";\n\n    let response = await spotifyFetch({ spotifyAccessToken, url });\n    dispatch(\n      playlistsReceived({\n        items: response.items,\n      })\n    );\n  } catch (error) {\n    console.log(error);\n  }\n\n  dispatch(setStatus(\"loaded\"));\n};\n\nconst { actions, reducer } = slice;\nconst { setStatus, playlistsReceived, setSelectedPlaylistId } = actions;\n\nexport { playlistsReceived, fetchPlaylists, setSelectedPlaylistId };\nexport default reducer;\n","export const getPlaylistId = (state) => state.albums.playlistId;\n\nexport const getStatus = (state) => state.albums.status;\n\nexport const getPagination = (state) => state.albums.pagination;\n\nexport const getSongs = (state) => state.albums.songs;\n\nexport const getAlbums = (state) => state.albums.albums;\n","import { createSlice } from \"@reduxjs/toolkit\";\nimport { groupBy } from \"lodash\";\n\nimport { spotifyFetch, playlistUrl } from \"../../lib/spotify-api\";\n\nimport { getPlaylistId, getPagination } from \"./selectors\";\n\nconst appSlice = createSlice({\n  name: \"albums\",\n  initialState: {\n    playlistId: \"\", // Interested\n    status: \"idle\",\n    pagination: {\n      offset: 0,\n      limit: 100,\n    },\n    albums: [],\n  },\n  reducers: {\n    setPlaylistId(state, action) {\n      state.playlistId = action.payload.playlistId;\n      // reset pagination, song list\n      state.pagination = {\n        offset: 0,\n        limit: 100,\n      };\n      state.songs = [];\n    },\n    setStatus(state, action) {\n      state.status = action.payload;\n    },\n    songsReceived(state, action) {\n      state.songs.push(...action.payload.items);\n      const { limit, offset } = action.payload;\n      state.pagination = {\n        limit,\n        offset,\n      };\n    },\n    showAlbums(state, action) {\n      state.albums = groupBy(state.songs, (song) => song?.track?.album?.id);\n\n      // get cover art in ..\n      // song?.track?.album?.images[0].url\n      // or sort images by image.size - probably always biggest in [0] though\n    },\n  },\n});\n\nconst { actions, reducer } = appSlice;\nconst {\n  setPlaylistId,\n  setStatus,\n  songsReceived,\n  showArtists,\n  showAlbums,\n} = actions;\n\nconst fetchSongs = ({ spotifyAccessToken }) => async (dispatch, state) => {\n  dispatch(setStatus(\"loading\"));\n\n  const current = state();\n  const playlistId = getPlaylistId(current);\n  const pagination = getPagination(current);\n\n  try {\n    let url = playlistUrl({ spotifyAccessToken, playlistId, ...pagination }),\n      response;\n    do {\n      response = await spotifyFetch({ spotifyAccessToken, url });\n      dispatch(\n        songsReceived({\n          items: response.items,\n          offset: response.offset + response.limit,\n          limit: response.limit,\n        })\n      );\n      url = response.next;\n    } while (url);\n  } catch (error) {\n    console.log(error);\n  }\n\n  dispatch(setStatus(\"loaded\"));\n\n  dispatch(showAlbums());\n};\n\nexport {\n  setPlaylistId,\n  setStatus,\n  songsReceived,\n  showArtists,\n  showAlbums,\n  fetchSongs,\n};\nexport default reducer;\n","import { configureStore } from \"@reduxjs/toolkit\";\n\nimport app from \"./app\";\nimport playlists from \"./playlists\";\nimport albums from \"./albums\";\n\nconst store = configureStore({\n  reducer: {\n    app,\n    playlists,\n    albums,\n  },\n});\n\nexport default store;\n","export const getApiToken = (state) => state.app.apiToken;\n\nexport const getView = (state) => state.app.view;\n\nexport const isAuthorised = (state) => state.app.apiToken.length > 0;\n","const development = {\n  clientId: 'db0460271efc4ab4b5f52fbe09ea4358',\n  redirectUrl: 'http://localhost:3000',\n};\n\nconst production = {\n  clientId: '6a53c434d5ce4fc2adb439113a5a7ec5',\n  redirectUrl: 'https://landscape.cartoonbeats.com/ajugi',\n};\n\nconst spotifyApp = ( process.env.NODE_ENV === 'production' ) ? production : development;\n\nexport default spotifyApp;","import React from 'react';\n\nimport spotifyApp from '../config/spotify.js';\n\nfunction AuthoriseSpotify() {\n  const spotifyAuthUrl = 'https://accounts.spotify.com/authorize?response_type=token'\n    + `&client_id=${ spotifyApp.clientId }`\n    + `&redirect_uri=${ spotifyApp.redirectUrl }`\n    // + `&state=${ randomString }`\n  ;\n\n  return (\n    <>\n      <p>\n        Click button to authorise with Spotify.\n      </p>\n      <a\n        href={ spotifyAuthUrl }\n        rel=\"noopener noreferrer\"\n      >\n        Authorise\n      </a>\n    </>\n  );\n}\n\nexport default AuthoriseSpotify;\n","export const getPlaylists = (state) => state.playlists.playlists;\n\nexport const getStatus = (state) => state.playlists.status;\n\nexport const getSelectedPlaylistId = (state) =>\n  state.playlists.selectedPlaylistId;\n","import React, { useEffect } from \"react\";\n\nimport { useSelector } from \"react-redux\";\n\nimport Button from \"@material-ui/core/Button\";\nimport List from \"@material-ui/core/List\";\nimport ListItem from \"@material-ui/core/ListItem\";\n\nimport store from \"../store/store.js\";\n\nimport { getApiToken } from \"../store/app/selectors\";\nimport { setView } from \"../store/app\";\nimport { setPlaylistId } from \"../store/albums\";\nimport { fetchPlaylists, setSelectedPlaylistId } from \"../store/playlists\";\nimport {\n  getPlaylists,\n  getSelectedPlaylistId,\n} from \"../store/playlists/selectors\";\n\nfunction Playlists() {\n  const apiToken = useSelector(getApiToken);\n  const playlists = useSelector(getPlaylists);\n  const selectedPlaylistId = useSelector(getSelectedPlaylistId);\n\n  // If there are no playlists, dispatch load action.\n  useEffect(() => {\n    if (playlists.length > 0 || !apiToken) {\n      return;\n    }\n    store.dispatch(fetchPlaylists({ spotifyAccessToken: apiToken }));\n  }, [apiToken, playlists]);\n\n  const button = selectedPlaylistId ? (\n    <Button\n      variant=\"contained\"\n      color=\"primary\"\n      onClick={() => {\n        store.dispatch(setPlaylistId({ playlistId: selectedPlaylistId }));\n        store.dispatch(setView({ view: \"albums\" }));\n      }}\n    >\n      Show Albums\n    </Button>\n  ) : null;\n\n  return (\n    <>\n      <List className=\"primary\">\n        {playlists?.map((playlist) => (\n          <ListItem\n            key={playlist.id}\n            selected={selectedPlaylistId === playlist.id}\n            onClick={() => {\n              store.dispatch(\n                setSelectedPlaylistId({ selectedPlaylistId: playlist.id })\n              );\n            }}\n          >\n            {playlist.name}\n          </ListItem>\n        ))}\n      </List>\n      {button}\n    </>\n  );\n}\n\nexport default Playlists;\n","import React, { useEffect } from \"react\";\n\nimport { useSelector } from \"react-redux\";\n\nimport store from \"../store/store.js\";\n\nimport { fetchSongs } from \"../store/albums\";\nimport { getStatus, getAlbums } from \"../store/albums/selectors\";\nimport { getApiToken } from \"../store/app/selectors\";\n\nimport \"./Albums.scss\";\n\nfunction Album({ id, albumSongs }) {\n  const album = albumSongs[0]?.track?.album;\n  if (!album) {\n    return null;\n  }\n\n  const coverImageUrl = album.images[0].url;\n  const title = album.name;\n  let releaseType = \"album\";\n  if (album.total_tracks < 7) {\n    releaseType = album.total_tracks > 3 ? \"ep\" : \"single\";\n  }\n\n  return <img className={releaseType} src={coverImageUrl} alt={title} />;\n}\n\nfunction Albums() {\n  const status = useSelector(getStatus);\n  const spotifyAccessToken = useSelector(getApiToken);\n  const albums = useSelector(getAlbums);\n\n  // Start loading songs on mount.\n  useEffect(() => {\n    store.dispatch(fetchSongs({ spotifyAccessToken }));\n  }, [spotifyAccessToken]);\n\n  if (status === \"loading\") {\n    return \"Loading songs…\";\n  }\n\n  if (!albums) {\n    return \"Grouping albums…\";\n  }\n\n  const cells = Object.entries(albums).map(([id, albumSongs]) => (\n    <Album key={id} id={id} albumSongs={albumSongs} />\n  ));\n\n  return <div className=\"Albums-container\">{cells}</div>;\n}\n\nexport default Albums;\n","import { useLocation } from 'react-router-dom';\n\nfunction useUrlHashParams() {\n  // Obtains named parameters from the hash section of the URL.\n  // Borrowed from Spotify API sample code.\n  var hashParams = {};\n  var r = /([^&;=]+)=?([^&;]*)/g,\n      q = useLocation().hash.substring(1);\n  let match = r.exec(q);\n  while ( match ) {\n    hashParams[ match[1] ] = decodeURIComponent( match[2] );\n    match = r.exec(q);\n  }\n  return hashParams;\n}\n\nexport default useUrlHashParams;\n","import React, { useEffect } from \"react\";\n\nimport { Provider, useSelector } from \"react-redux\";\n\nimport { BrowserRouter as Router } from \"react-router-dom\";\n\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\nimport { ThemeProvider } from \"@material-ui/core/styles\";\nimport Container from \"@material-ui/core/Container\";\n\nimport theme from \"./theme\";\n\nimport store from \"./store/store.js\";\nimport { setApiToken } from \"./store/app\";\nimport { getApiToken, getView } from \"./store/app/selectors\";\n\nimport AuthoriseSpotify from \"./components/AuthoriseSpotify.js\";\nimport Playlists from \"./components/Playlists.js\";\nimport Albums from \"./components/Albums.js\";\n\nimport useUrlHashParams from \"./lib/useUrlHashParams.js\";\n\n// Main application content component.\n// Logic for determining what view to show (e.g. auth or playlists).\nfunction AppContent() {\n  // Wrangle our API token.\n  // The token is delivered from Spotify API via `#access_token` url param.\n  // We store it in our redux state.\n  // We use an effect to persist the token to local storage, or use a\n  // previously-saved token, by dispatching action to update store.\n  const { access_token: urlApiToken } = useUrlHashParams();\n  const apiToken = useSelector(getApiToken);\n  const view = useSelector(getView);\n\n  useEffect(() => {\n    const savedApiToken = window.localStorage.getItem(\"apiToken\");\n    if (urlApiToken && savedApiToken !== urlApiToken) {\n      // New token in URL - persist to storage for next time.\n      window.localStorage.setItem(\"apiToken\", urlApiToken);\n      store.dispatch(setApiToken({ apiToken: urlApiToken }));\n    } else {\n      // No new token - use the saved one.\n      store.dispatch(setApiToken({ apiToken: savedApiToken }));\n    }\n  }, [urlApiToken]);\n\n  if (!apiToken) {\n    return <AuthoriseSpotify />;\n  }\n\n  if (view === \"playlists\") {\n    return <Playlists />;\n  }\n\n  if (view === \"albums\") {\n    return <Albums />;\n  }\n}\n\n// Top-level app component with theme, store provider etc.\n// Router is used so we can get access to url params via useLocation.\n// (We're not actually using any routing, so we can deploy to GitHub Pages.)\nfunction AppContainer() {\n  return (\n    <ThemeProvider theme={theme}>\n      <CssBaseline />\n      <Container>\n        <Router>\n          <Provider store={store}>\n            <AppContent />\n          </Provider>\n        </Router>\n      </Container>\n    </ThemeProvider>\n  );\n}\n\nexport default AppContainer;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}