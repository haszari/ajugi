{"version":3,"sources":["theme.js","lib/spotify-api.js","store/app/selectors.js","store/app/slice.js","store/store.js","config/spotify.js","components/AuthoriseSpotify.js","lib/useUrlHashParams.js","components/Playlists.js","App.js","serviceWorker.js","index.js"],"names":["theme","createMuiTheme","palette","primary","main","secondary","error","orange","A400","background","default","baseUrl","spotifyFetch","a","spotifyAccessToken","url","fetch","headers","Authorization","response","json","appSlice","createSlice","name","initialState","playlistId","loading","pagination","offset","limit","view","songs","groupedBy","groups","reducers","setPlaylistId","state","action","payload","startLoading","finishLoading","songsReceived","push","items","showArtists","groupBy","song","track","artists","id","showAlbums","album","actions","reducer","store","configureStore","app","spotifyApp","clientId","redirectUrl","AuthoriseSpotify","spotifyAuthUrl","href","rel","useUrlHashParams","hashParams","r","q","useLocation","hash","substring","match","exec","decodeURIComponent","Playlists","access_token","useState","playlists","setPlaylists","useEffect","length","then","console","log","map","playlist","key","App","ThemeProvider","CssBaseline","Container","path","children","Boolean","window","location","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.9365e3f1.chunk.js","sourcesContent":["import { orange } from \"@material-ui/core/colors\";\nimport { createMuiTheme } from \"@material-ui/core/styles\";\n\n// A custom theme for this app\nconst theme = createMuiTheme({\n  palette: {\n    primary: {\n      main: \"#ff0022\",\n    },\n    secondary: {\n      main: \"#22ff00\",\n    },\n    error: {\n      main: orange.A400,\n    },\n    background: {\n      default: \"#aaa\",\n    },\n  },\n});\n\nexport default theme;\n","\n\nconst baseUrl = 'https://api.spotify.com/v1/';\n\nasync function spotifyFetch( { \n  spotifyAccessToken, \n  url, \n} ) {\n  const response = await fetch(\n    url,\n    {    \n      headers: {\n        Authorization: `Bearer ${ spotifyAccessToken }`\n      },\n    }\n  );\n  return response.json();\n}\n\nfunction playlistUrl( { \n  playlistId, \n  offset = 0, \n  limit = 100,\n} ) {\n  const playlistUrl = new URL( `${ baseUrl }playlists/${ playlistId }/tracks` );\n  playlistUrl.searchParams.append( 'offset', offset );\n  playlistUrl.searchParams.append( 'limit', limit );\n  return playlistUrl.href;\n};\n\n\nexport { \n  baseUrl,\n  spotifyFetch, \n  playlistUrl,\n};","export const getPlaylistId = (state) => state.app.playlistId;\n\nexport const getLoading = (state) => state.app.loading;\n\nexport const getPagination = (state) => state.app.pagination;\n\nexport const getSongs = (state) => state.app.songs;\n\nexport const getGroups = (state) => state.app.groups;\n\nexport const getView = (state) => state.app.view;\n","import { createSlice } from \"@reduxjs/toolkit\";\nimport { groupBy } from \"lodash\";\n\nimport { spotifyFetch, playlistUrl } from \"../../lib/spotify-api\";\n\nimport { getPlaylistId, getPagination } from \"./selectors\";\n\nconst appSlice = createSlice({\n  name: \"app\",\n  initialState: {\n    playlistId: \"43m3aAgpbJnoanT48x8ZKI\", // Interested\n    // playlistId: \"2P3C1iQgwoOnSEQKSRmDTw\", // Starland Classical\n    loading: \"idle\",\n    pagination: {\n      offset: 0,\n      limit: 100,\n    },\n    view: \"songs\",\n    songs: [],\n    groupedBy: \"\",\n    groups: [],\n  },\n  reducers: {\n    setPlaylistId(state, action) {\n      state.playlistId = action.payload;\n      // reset pagination, song list\n      state.pagination = {\n        offset: 0,\n        limit: 100,\n      };\n      state.songs = [];\n    },\n    startLoading(state, action) {\n      state.loading = \"loading\";\n    },\n    finishLoading(state, action) {\n      state.loading = \"loaded\";\n    },\n    songsReceived(state, action) {\n      state.songs.push(...action.payload.items);\n      const { limit, offset } = action.payload;\n      state.pagination = {\n        limit,\n        offset,\n      };\n    },\n    showArtists(state, action) {\n      state.groups = groupBy(\n        state.songs,\n        (song) => song?.track?.artists[0]?.id\n      );\n      state.view = \"artists\";\n    },\n    showAlbums(state, action) {\n      state.groups = groupBy(state.songs, (song) => song?.track?.album?.id);\n      state.view = \"albums\";\n\n      // get cover art in ..\n      // song?.track?.album?.images[0].url\n      // or sort images by image.size - probably always biggest in [0] though\n    },\n  },\n});\n\nconst { actions, reducer } = appSlice;\nconst {\n  setPlaylistId,\n  startLoading,\n  finishLoading,\n  songsReceived,\n  showArtists,\n  showAlbums,\n} = actions;\n\nconst fetchSongs = ({ spotifyAccessToken }) => async (dispatch, state) => {\n  dispatch(startLoading());\n\n  const current = state();\n  const playlistId = getPlaylistId(current);\n  const pagination = getPagination(current);\n\n  try {\n    let url = playlistUrl({ spotifyAccessToken, playlistId, ...pagination }),\n      response;\n    do {\n      response = await spotifyFetch({ spotifyAccessToken, url });\n      dispatch(\n        songsReceived({\n          items: response.items,\n          offset: response.offset + response.limit,\n          limit: response.limit,\n        })\n      );\n      url = response.next;\n    } while (url);\n  } catch (error) {\n    console.log(error);\n  }\n\n  dispatch(finishLoading());\n};\n\nexport {\n  setPlaylistId,\n  startLoading,\n  finishLoading,\n  songsReceived,\n  showArtists,\n  showAlbums,\n  fetchSongs,\n};\nexport default reducer;\n","import { configureStore } from '@reduxjs/toolkit';\n\nimport app from './app/slice';\n\nconst store = configureStore( {\n  reducer: {\n    app,\n  }\n} );\n\nexport default store;","const development = {\n  clientId: 'db0460271efc4ab4b5f52fbe09ea4358',\n  redirectUrl: 'http://localhost:3000',\n};\n\nconst production = {\n  clientId: '6a53c434d5ce4fc2adb439113a5a7ec5',\n  redirectUrl: 'https://landscape.cartoonbeats.com/ajugi',\n};\n\nconst spotifyApp = ( process.env.NODE_ENV === 'production' ) ? production : development;\n\nexport default spotifyApp;","import React from 'react';\n\nimport spotifyApp from '../config/spotify.js';\n\nfunction AuthoriseSpotify() {\n  const spotifyAuthUrl = 'https://accounts.spotify.com/authorize?response_type=token'\n    + `&client_id=${ spotifyApp.clientId }`\n    + `&redirect_uri=${ spotifyApp.redirectUrl }`\n    // + `&state=${ randomString }`\n  ;\n\n  return (\n    <>\n      <p>\n        Click button to authorise with Spotify.\n      </p>\n      <a\n        href={ spotifyAuthUrl }\n        rel=\"noopener noreferrer\"\n      >\n        Authorise\n      </a>\n    </>\n  );\n}\n\nexport default AuthoriseSpotify;\n","import { useLocation } from 'react-router-dom';\n\nfunction useUrlHashParams() {\n  // Obtains named parameters from the hash section of the URL.\n  // Borrowed from Spotify API sample code.\n  var hashParams = {};\n  var r = /([^&;=]+)=?([^&;]*)/g,\n      q = useLocation().hash.substring(1);\n  let match = r.exec(q);\n  while ( match ) {\n    hashParams[ match[1] ] = decodeURIComponent( match[2] );\n    match = r.exec(q);\n  }\n  return hashParams;\n}\n\nexport default useUrlHashParams;\n","import React, { useState, useEffect } from \"react\";\n\n\nimport AuthoriseSpotify from \"./AuthoriseSpotify.js\";\n\nimport { baseUrl, spotifyFetch } from \"../lib/spotify-api\";\n\nimport useUrlHashParams from \"../lib/useUrlHashParams.js\";\n\nfunction Playlists() {\n  const { access_token: spotifyAccessToken } = useUrlHashParams();\n\n  const [ playlists, setPlaylists ] = useState( [] );\n\n  // If playlists are empty, fetch em.\n  // This is basically a demo/temporary.\n  useEffect( () => {\n    if ( playlists.length > 0 || ! spotifyAccessToken ) { return };\n\n    spotifyFetch( {\n      spotifyAccessToken, \n      url: baseUrl + 'me/playlists',\n    } ).then( response => {\n      console.log( response.items );\n      setPlaylists( response.items );\n    } );  \n  }, [ spotifyAccessToken, playlists, setPlaylists ] );\n\n  if ( ! spotifyAccessToken ) {\n    return (<AuthoriseSpotify />);\n  }\n\n  return (\n    <>\n      {\n        playlists.map( ( playlist ) => (\n          <div key={ playlist.id }>{ playlist.name }</div>\n        ) )\n      }\n    </>\n  );\n}\n\nexport default Playlists;\n","import React from \"react\";\n\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport { Provider } from \"react-redux\";\n\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\nimport { ThemeProvider } from \"@material-ui/core/styles\";\nimport Container from \"@material-ui/core/Container\";\n\nimport theme from \"./theme\";\n\nimport store from \"./store/store.js\";\n\nimport Playlists from \"./components/Playlists.js\";\n\nfunction App() {\n  return (\n    <ThemeProvider theme={theme}>\n      <CssBaseline />\n      <Container>\n        <Router>\n          <Provider store={store}>\n            <Switch>\n              <Route path=\"/\" children={<Playlists />} />\n            </Switch>\n          </Provider>\n        </Router>\n      </Container>\n    </ThemeProvider>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}