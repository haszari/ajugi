{"version":3,"sources":["theme.js","store/app/index.js","lib/spotify-api.js","store/playlists/index.js","store/albums/selectors.js","store/albums/index.js","store/store.js","store/app/selectors.js","config/spotify.js","components/AuthoriseSpotify.js","store/playlists/selectors.js","components/Playlists.js","components/Albums.js","lib/useUrlHashParams.js","App.js","serviceWorker.js","index.js"],"names":["theme","createMuiTheme","slice","createSlice","name","initialState","apiToken","view","reducers","setApiToken","state","action","payload","setView","clearStaleApiToken","actions","reducer","baseUrl","spotifyFetch","a","spotifyAccessToken","url","fetch","headers","Authorization","response","ok","json","window","localStorage","setItem","store","dispatch","playlistUrl","playlistId","offset","limit","URL","searchParams","append","href","status","playlists","selectedPlaylistId","setStatus","playlistsReceived","push","items","setSelectedPlaylistId","getPlaylistId","albums","getStatus","getPagination","pagination","getAlbums","getSelectedAlbumId","selectedAlbumId","appSlice","setPlaylistId","songs","songsReceived","showAlbums","groupBy","song","track","album","id","setSelectedAlbumId","showArtists","configureStore","app","getApiToken","getView","spotifyApp","clientId","redirectUrl","scopes","AuthoriseSpotify","spotifyAuthUrl","encodeURIComponent","rel","getPlaylists","getSelectedPlaylistId","Playlists","useSelector","useEffect","length","console","log","fetchPlaylists","button","Button","variant","color","onClick","List","className","map","playlist","ListItem","key","selected","Album","albumSongs","isSelected","artist","artists","title","releaseDate","release_date","coverImageUrl","images","uri","releaseType","total_tracks","infoBox","playStartUrl","method","body","JSON","stringify","context_uri","playItem","classnames","src","alt","Albums","current","next","fetchSongs","cells","Object","entries","useUrlHashParams","hashParams","r","q","useLocation","hash","substring","match","exec","decodeURIComponent","AppContent","urlApiToken","access_token","savedApiToken","getItem","AppContainer","ThemeProvider","CssBaseline","Container","Boolean","location","hostname","ReactDOM","render","StrictMode","App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.1d0d7242.chunk.js","sourcesContent":["import { createMuiTheme } from \"@material-ui/core/styles\";\n\n// A custom theme for this app…\n// …or not, need to better understand how to define a custom theme from 1-3 colours.\nconst theme = createMuiTheme({\n  // palette: {\n  //   primary: {\n  //     main: \"#ff0022\",\n  //   },\n  //   secondary: {\n  //     main: \"#22ff00\",\n  //   },\n  //   error: {\n  //     main: orange.A400,\n  //   },\n  //   background: {\n  //     default: \"#cga\",\n  //   },\n  //   action: {\n  //     selected: \"green\",\n  //   },\n  // },\n});\n\nexport default theme;\n","import { createSlice } from \"@reduxjs/toolkit\";\n\nconst slice = createSlice({\n  name: \"spotifyClient\",\n  initialState: {\n    apiToken: \"\",\n    view: \"playlists\",\n  },\n  reducers: {\n    setApiToken(state, action) {\n      state.apiToken = action.payload.apiToken;\n    },\n    setView(state, action) {\n      state.view = action.payload.view;\n    },\n  },\n});\n\nconst clearStaleApiToken = () => setApiToken({ apiToken: \"\" });\n\nconst { actions, reducer } = slice;\nconst { setApiToken, setView } = actions;\n\nexport { clearStaleApiToken, setApiToken, setView };\nexport default reducer;\n","import store from \"../store/store.js\";\nimport { clearStaleApiToken } from \"../store/app\";\n\nconst baseUrl = \"https://api.spotify.com/v1/\";\n\nasync function spotifyFetch({ spotifyAccessToken, url }) {\n  const response = await fetch(url, {\n    headers: {\n      Authorization: `Bearer ${spotifyAccessToken}`,\n    },\n  });\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  window.localStorage.setItem(\"apiToken\", \"\");\n  store.dispatch(clearStaleApiToken());\n  return [];\n}\n\nfunction playItem({ spotifyAccessToken, uri }) {\n  const playStartUrl = new URL(`${baseUrl}me/player/play`);\n  fetch(playStartUrl, {\n    method: \"PUT\",\n    headers: {\n      Authorization: `Bearer ${spotifyAccessToken}`,\n    },\n    body: JSON.stringify({\n      context_uri: uri,\n    }),\n  });\n}\n\nfunction playlistUrl({ playlistId, offset = 0, limit = 100 }) {\n  const playlistUrl = new URL(`${baseUrl}playlists/${playlistId}/tracks`);\n  playlistUrl.searchParams.append(\"offset\", offset);\n  playlistUrl.searchParams.append(\"limit\", limit);\n  return playlistUrl.href;\n}\n\nexport { baseUrl, spotifyFetch, playItem, playlistUrl };\n","import { createSlice } from \"@reduxjs/toolkit\";\n\nimport { baseUrl, spotifyFetch } from \"../../lib/spotify-api\";\n\nconst slice = createSlice({\n  name: \"playlists\",\n  initialState: {\n    status: \"idle\",\n    playlists: [],\n    selectedPlaylistId: \"\",\n  },\n  reducers: {\n    setStatus(state, action) {\n      state.status = action.payload.status;\n    },\n    playlistsReceived(state, action) {\n      state.playlists.push(...action.payload.items);\n    },\n    setSelectedPlaylistId(state, action) {\n      state.selectedPlaylistId = action.payload.selectedPlaylistId;\n    },\n  },\n});\n\nconst fetchPlaylists = ({ spotifyAccessToken }) => async (dispatch, state) => {\n  dispatch(setStatus(\"loading\"));\n\n  try {\n    let url = baseUrl + \"me/playlists\";\n\n    let response = await spotifyFetch({ spotifyAccessToken, url });\n    dispatch(\n      playlistsReceived({\n        items: response.items,\n      })\n    );\n  } catch (error) {\n    console.log(error);\n  }\n\n  dispatch(setStatus(\"loaded\"));\n};\n\nconst { actions, reducer } = slice;\nconst { setStatus, playlistsReceived, setSelectedPlaylistId } = actions;\n\nexport { playlistsReceived, fetchPlaylists, setSelectedPlaylistId };\nexport default reducer;\n","export const getPlaylistId = (state) => state.albums.playlistId;\n\nexport const getStatus = (state) => state.albums.status;\n\nexport const getPagination = (state) => state.albums.pagination;\n\nexport const getSongs = (state) => state.albums.songs;\n\nexport const getAlbums = (state) => state.albums.albums;\n\nexport const getSelectedAlbumId = (state) => state.albums.selectedAlbumId;\n","import { createSlice } from \"@reduxjs/toolkit\";\nimport { groupBy } from \"lodash\";\n\nimport { spotifyFetch, playlistUrl } from \"../../lib/spotify-api\";\n\nimport { getPlaylistId, getPagination } from \"./selectors\";\n\nconst appSlice = createSlice({\n  name: \"albums\",\n  initialState: {\n    playlistId: \"\", // Interested\n    status: \"idle\",\n    pagination: {\n      offset: 0,\n      limit: 100,\n    },\n    // albums, keyed by spotify id\n    albums: {},\n    selectedAlbumId: \"\",\n  },\n  reducers: {\n    setPlaylistId(state, action) {\n      state.playlistId = action.payload.playlistId;\n      // reset pagination, song list\n      state.pagination = {\n        offset: 0,\n        limit: 100,\n      };\n      state.songs = [];\n    },\n    setStatus(state, action) {\n      state.status = action.payload;\n    },\n    songsReceived(state, action) {\n      state.songs.push(...action.payload.items);\n      const { limit, offset } = action.payload;\n      state.pagination = {\n        limit,\n        offset,\n      };\n    },\n    showAlbums(state, action) {\n      state.albums = groupBy(state.songs, (song) => song?.track?.album?.id);\n    },\n    setSelectedAlbumId(state, action) {\n      state.selectedAlbumId = action.payload;\n    },\n  },\n});\n\nconst { actions, reducer } = appSlice;\nconst {\n  setPlaylistId,\n  setStatus,\n  setSelectedAlbumId,\n  songsReceived,\n  showArtists,\n  showAlbums,\n} = actions;\n\nconst fetchSongs = ({ spotifyAccessToken }) => async (dispatch, state) => {\n  dispatch(setStatus(\"loading\"));\n\n  const current = state();\n  const playlistId = getPlaylistId(current);\n  const pagination = getPagination(current);\n\n  try {\n    let url = playlistUrl({ spotifyAccessToken, playlistId, ...pagination }),\n      response;\n    do {\n      response = await spotifyFetch({ spotifyAccessToken, url });\n      dispatch(\n        songsReceived({\n          items: response.items,\n          offset: response.offset + response.limit,\n          limit: response.limit,\n        })\n      );\n      url = response.next;\n    } while (url);\n  } catch (error) {\n    console.log(error);\n  }\n\n  dispatch(setStatus(\"loaded\"));\n\n  dispatch(showAlbums());\n};\n\nexport {\n  setPlaylistId,\n  setStatus,\n  songsReceived,\n  setSelectedAlbumId,\n  showArtists,\n  showAlbums,\n  fetchSongs,\n};\nexport default reducer;\n","import { configureStore } from \"@reduxjs/toolkit\";\n\nimport app from \"./app\";\nimport playlists from \"./playlists\";\nimport albums from \"./albums\";\n\nconst store = configureStore({\n  reducer: {\n    app,\n    playlists,\n    albums,\n  },\n});\n\nexport default store;\n","export const getApiToken = (state) => state.app.apiToken;\n\nexport const getView = (state) => state.app.view;\n\nexport const isAuthorised = (state) => state.app.apiToken.length > 0;\n","const scopes =\n  \"user-read-private user-read-email streaming app-remote-control user-modify-playback-state\";\n\nconst development = {\n  clientId: \"db0460271efc4ab4b5f52fbe09ea4358\",\n  redirectUrl: \"http://localhost:3000\",\n};\n\nconst production = {\n  clientId: \"6a53c434d5ce4fc2adb439113a5a7ec5\",\n  redirectUrl: \"https://landscape.cartoonbeats.com/ajugi\",\n};\n\nconst spotifyApp =\n  process.env.NODE_ENV === \"production\" ? production : development;\n\nexport default { ...spotifyApp, scopes };\n","import React from \"react\";\n\nimport spotifyApp from \"../config/spotify.js\";\n\nfunction AuthoriseSpotify() {\n  const spotifyAuthUrl =\n    \"https://accounts.spotify.com/authorize?response_type=token\" +\n    `&client_id=${spotifyApp.clientId}` +\n    `&redirect_uri=${spotifyApp.redirectUrl}` +\n    `&scope=${encodeURIComponent(spotifyApp.scopes)}`;\n  // + `&state=${ randomString }`\n  return (\n    <>\n      <p>Click button to authorise with Spotify.</p>\n      <a href={spotifyAuthUrl} rel=\"noopener noreferrer\">\n        Authorise\n      </a>\n    </>\n  );\n}\n\nexport default AuthoriseSpotify;\n","export const getPlaylists = (state) => state.playlists.playlists;\n\nexport const getStatus = (state) => state.playlists.status;\n\nexport const getSelectedPlaylistId = (state) =>\n  state.playlists.selectedPlaylistId;\n","import React, { useEffect } from \"react\";\n\nimport { useSelector } from \"react-redux\";\n\nimport Button from \"@material-ui/core/Button\";\nimport List from \"@material-ui/core/List\";\nimport ListItem from \"@material-ui/core/ListItem\";\n\nimport store from \"../store/store.js\";\n\nimport { getApiToken } from \"../store/app/selectors\";\nimport { setView } from \"../store/app\";\nimport { setPlaylistId } from \"../store/albums\";\nimport { fetchPlaylists, setSelectedPlaylistId } from \"../store/playlists\";\nimport {\n  getPlaylists,\n  getSelectedPlaylistId,\n} from \"../store/playlists/selectors\";\n\nfunction Playlists() {\n  const apiToken = useSelector(getApiToken);\n  const playlists = useSelector(getPlaylists);\n  const selectedPlaylistId = useSelector(getSelectedPlaylistId);\n\n  // If there are no playlists, dispatch load action.\n  useEffect(() => {\n    if (playlists.length > 0 || !apiToken) {\n      return;\n    }\n    store.dispatch(fetchPlaylists({ spotifyAccessToken: apiToken }));\n  }, [apiToken, playlists]);\n\n  const button = selectedPlaylistId ? (\n    <Button\n      variant=\"contained\"\n      color=\"primary\"\n      onClick={() => {\n        store.dispatch(setPlaylistId({ playlistId: selectedPlaylistId }));\n        store.dispatch(setView({ view: \"albums\" }));\n      }}\n    >\n      Show Albums\n    </Button>\n  ) : null;\n\n  return (\n    <>\n      <List className=\"primary\">\n        {playlists?.map((playlist) => (\n          <ListItem\n            key={playlist.id}\n            selected={selectedPlaylistId === playlist.id}\n            onClick={() => {\n              store.dispatch(\n                setSelectedPlaylistId({ selectedPlaylistId: playlist.id })\n              );\n            }}\n          >\n            {playlist.name}\n          </ListItem>\n        ))}\n      </List>\n      {button}\n    </>\n  );\n}\n\nexport default Playlists;\n","import React, { useEffect } from \"react\";\n\nimport { useSelector } from \"react-redux\";\n\nimport Button from \"@material-ui/core/Button\";\n\nimport classnames from \"classnames\";\n\nimport { playItem } from \"../lib/spotify-api\";\n\nimport store from \"../store/store.js\";\n\nimport { fetchSongs, setSelectedAlbumId } from \"../store/albums\";\nimport {\n  getStatus,\n  getAlbums,\n  getSelectedAlbumId,\n} from \"../store/albums/selectors\";\nimport { getApiToken } from \"../store/app/selectors\";\n\nimport \"./Albums.scss\";\n\nfunction Album({ id, albumSongs, isSelected }) {\n  const spotifyAccessToken = useSelector(getApiToken);\n  const album = albumSongs[0]?.track?.album;\n  if (!album) {\n    return null;\n  }\n\n  const artist = album.artists[0]?.name;\n  const title = album.name;\n  const releaseDate = album.release_date;\n  const coverImageUrl = album.images[0]?.url;\n  const uri = album.uri;\n  let releaseType = \"album\";\n  if (album.total_tracks < 7) {\n    releaseType = album.total_tracks > 3 ? \"ep\" : \"single\";\n  }\n\n  const onCoverClick = () => {\n    if (isSelected) {\n      store.dispatch(setSelectedAlbumId(\"\"));\n    } else {\n      store.dispatch(setSelectedAlbumId(id));\n    }\n  };\n\n  const playAlbum = () => {\n    playItem({ spotifyAccessToken, uri });\n  };\n\n  const infoBox = isSelected ? (\n    <div className=\"info\">\n      <div className=\"artist\">{artist}</div>\n      <div className=\"title\">{title}</div>\n      <div className=\"releaseDate\">{releaseDate}</div>\n\n      <Button variant=\"contained\" color=\"primary\" onClick={playAlbum}>\n        Play\n      </Button>\n    </div>\n  ) : null;\n\n  return (\n    <div className={classnames(\"release\", releaseType, { isSelected })}>\n      <img onClick={onCoverClick} src={coverImageUrl} alt={title} />\n      {infoBox}\n    </div>\n  );\n}\n\nfunction Albums() {\n  const status = useSelector(getStatus);\n  const spotifyAccessToken = useSelector(getApiToken);\n  const selectedAlbumId = useSelector(getSelectedAlbumId);\n  const albums = useSelector(getAlbums);\n\n  // Start loading songs on mount.\n  useEffect(() => {\n    store.dispatch(fetchSongs({ spotifyAccessToken }));\n  }, [spotifyAccessToken]);\n\n  if (status === \"loading\") {\n    return \"Loading songs…\";\n  }\n\n  if (!albums) {\n    return \"Grouping albums…\";\n  }\n\n  const cells = Object.entries(albums).map(([id, albumSongs]) => (\n    <Album\n      key={id}\n      id={id}\n      albumSongs={albumSongs}\n      isSelected={id === selectedAlbumId}\n    />\n  ));\n\n  return <div className=\"Albums-container\">{cells}</div>;\n}\n\nexport default Albums;\n","import { useLocation } from 'react-router-dom';\n\nfunction useUrlHashParams() {\n  // Obtains named parameters from the hash section of the URL.\n  // Borrowed from Spotify API sample code.\n  var hashParams = {};\n  var r = /([^&;=]+)=?([^&;]*)/g,\n      q = useLocation().hash.substring(1);\n  let match = r.exec(q);\n  while ( match ) {\n    hashParams[ match[1] ] = decodeURIComponent( match[2] );\n    match = r.exec(q);\n  }\n  return hashParams;\n}\n\nexport default useUrlHashParams;\n","import React, { useEffect } from \"react\";\n\nimport { Provider, useSelector } from \"react-redux\";\n\nimport { BrowserRouter as Router } from \"react-router-dom\";\n\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\nimport { ThemeProvider } from \"@material-ui/core/styles\";\nimport Container from \"@material-ui/core/Container\";\n\nimport theme from \"./theme\";\n\nimport store from \"./store/store.js\";\nimport { setApiToken } from \"./store/app\";\nimport { getApiToken, getView } from \"./store/app/selectors\";\n\nimport AuthoriseSpotify from \"./components/AuthoriseSpotify.js\";\nimport Playlists from \"./components/Playlists.js\";\nimport Albums from \"./components/Albums.js\";\n\nimport useUrlHashParams from \"./lib/useUrlHashParams.js\";\n\n// Main application content component.\n// Logic for determining what view to show (e.g. auth or playlists).\nfunction AppContent() {\n  // Wrangle our API token.\n  // The token is delivered from Spotify API via `#access_token` url param.\n  // We store it in our redux state.\n  // We use an effect to persist the token to local storage, or use a\n  // previously-saved token, by dispatching action to update store.\n  const { access_token: urlApiToken } = useUrlHashParams();\n  const apiToken = useSelector(getApiToken);\n  const view = useSelector(getView);\n\n  useEffect(() => {\n    const savedApiToken = window.localStorage.getItem(\"apiToken\");\n    if (urlApiToken && savedApiToken !== urlApiToken) {\n      // New token in URL - persist to storage for next time.\n      window.localStorage.setItem(\"apiToken\", urlApiToken);\n      store.dispatch(setApiToken({ apiToken: urlApiToken }));\n    } else {\n      // No new token - use the saved one.\n      store.dispatch(setApiToken({ apiToken: savedApiToken }));\n    }\n  }, [urlApiToken]);\n\n  if (!apiToken) {\n    return <AuthoriseSpotify />;\n  }\n\n  if (view === \"playlists\") {\n    return <Playlists />;\n  }\n\n  if (view === \"albums\") {\n    return <Albums />;\n  }\n}\n\n// Top-level app component with theme, store provider etc.\n// Router is used so we can get access to url params via useLocation.\n// (We're not actually using any routing, so we can deploy to GitHub Pages.)\nfunction AppContainer() {\n  return (\n    <ThemeProvider theme={theme}>\n      <CssBaseline />\n      <Container>\n        <Router>\n          <Provider store={store}>\n            <AppContent />\n          </Provider>\n        </Router>\n      </Container>\n    </ThemeProvider>\n  );\n}\n\nexport default AppContainer;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}